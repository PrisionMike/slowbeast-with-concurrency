#!/usr/bin/python3

from sys import exit
import argparse
from os import mkdir
from shutil import rmtree
from os.path import join as pathjoin

from slowbeast.parsers.llvm import Parser as LLVMParser
from slowbeast.symexe.symbolicexecution import SEOptions
from slowbeast.util.debugging import set_debugging, print_stdout, print_stderr

def createArgParser():
    parser = argparse.ArgumentParser()
    parser.add_argument('prog', nargs=1, help='program to be analyzed')
    parser.add_argument('-dbg', action='store_true', help='write debugging messages')
    parser.add_argument('-entry', default='main', help='entry function')
    parser.add_argument('-out-dir', default='sb-out', help='Directory for output files')
    parser.add_argument('-interactive', action='store_true', default=False, help='Introspect the run of the algorithm')
    parser.add_argument('-no-output', action='store_true', default=False, help='Genereate no output (other than stdout/stderr)')
    parser.add_argument('-no-tests', action='store_true', help='Genereate no test files')
    parser.add_argument('-all-tests', action='store_true', default=False, help='Genereate tests for all paths (not only the erroneous)')
    parser.add_argument('-step', default='instr',
                        help='Set what is an execution step, one of: block, instr (block = execute the whole blocks instead of single instructions in one step.')
    parser.add_argument('-concretize-nondet', action='store_true', default=False,
                        help='Use random value for nondet values, thus follow one random path during execution.')
    parser.add_argument('-uninitialized-nondet', action='store_true', default=False,
                        help='Use nondet value for reads from uninitialized memory (instead of issuing an error).')
    parser.add_argument('-parse-only', action='store_true', help='only parse program and dump it (for debugging)')
    parser.add_argument('-kind', action='store_true', help='Use k-induction')
    parser.add_argument('-se', action='store_true', default=True,  help='Perform symbolic execution.')
    #parser.add_argument('-bmc', action='store_true', help='Perform bounded model checking.')

    return parser

def parseArgs():
    parser = createArgParser()
    args = parser.parse_args()

    valid_step = ['block', 'instr']

    if not args.step in valid_step:
        print_stderr("Invalid -step argument, must be one of: {0}, got '{1}'".format(valid_step, args.step),
                     color="RED")
        exit(1)

    return args

def print_stats(engine):
    print_stdout(
        "Executed steps till branch: {0}".format(
            engine.getExecutor().getExecStepNum()),
        color='CYAN')
    print_stdout(
        "Executed instructions: {0}".format(
            engine.getExecutor().getExecInstrNum()),
        color='CYAN')
    print_stdout(
        "Executed paths: {0}".format(
            engine.stats.paths),
        color='CYAN')
    print_stdout(
        "Paths that reached exit: {0}".format(
            engine.stats.exited_paths),
        color='CYAN')
    print_stdout(
        "Paths that abnormally terminated: {0}".format(
            engine.stats.terminated_paths),
        color='CYAN')
    print_stdout(
        "Killed paths: {0}".format( engine.stats.killed_paths), color='CYAN')
    print_stdout(
        "Executed branch instructions: {0}".format(
            engine.getExecutor().stats.branchings),
        color='CYAN')
    print_stdout(
        "Number of forks on branches: {0} (forked on {1}% of branches)".format(
            engine.getExecutor().stats.branch_forks,
            0 if engine.getExecutor().stats.branchings == 0 else
            100 *
            float(
                engine.getExecutor().stats.branch_forks) /
            engine.getExecutor().stats.branchings),
        color='CYAN')
    # this includes e.g. forks on assertions/memory resolution/etc.
    print_stdout(
        "Number of all forks: {0} (from {1} calls ({2}%) to fork())".format(
            engine.getExecutor().stats.forks,
            engine.getExecutor().stats.fork_calls,
            0 if engine.getExecutor().stats.fork_calls == 0 else
            100 *
            float(
                engine.getExecutor().stats.forks) /
            engine.getExecutor().stats.fork_calls),
        color='CYAN')
    print_stdout(
        "Found errors: {0}".format(
            engine.stats.errors),
        color='CYAN')

class TestCaseGenerator:
    def __init__(self, outdir='sb-out', alltests=False):
        self._outputdir = outdir
        self._alltests = alltests

    def _openfile(self, path):
        return open(pathjoin(self._outputdir, path), 'w')

    def processErrorState(self, fl, state):
        fl.write(state.getError())
        fl.write('\n')
        fl.write('\n')
        fl.write("Nondeterministic values:\n")
        inpvec = state.concretize(*state.getNondets())
        for var, val in zip(state.getNondets(), inpvec):
            # dump as unsigned and signed
            fl.write("  {0} -> {1} ({2})\n".format(var, val,
                                                   (val.getValue() - (1 << val.getBitWidth()))))
        fl.write('\n')
        state.dump(stream=fl)

    def processState(self, state):
        assert not state.isReady()

        if not self._alltests and state.exited():
            return

        filename=str(state.getID())
        if state.hasError():
            filename+= ".err"
        elif state.wasKilled():
            filename+= ".killed"
        elif state.isTerminated():
            filename+= ".abort"
        filename+=".test"

        with self._openfile(filename) as fl:
            fl.write(str(state.getStatus()))
            fl.write('\n')
            if state.hasError():
                self.processErrorState(fl, state)
            else:
                fl.write('\n')
                state.dump(stream=fl)


def main():
    args = parseArgs()

    parser = LLVMParser()
    try:
        P = parser.parse(args.prog[0])
    except FileNotFoundError as e:
        print_stderr(str(e), color="RED")
        exit(1)
    if not P:
        exit(1)

    if args.parse_only:
        P.dump()
        exit(0)

    if args.dbg:
        set_debugging()
        P.dump()

    entry = P.getFunction(args.entry)
    if not entry:
        print("Entry function not found: {0}".format(args.entry))
        exit(1)

    testgen=None
    if not args.no_output:
        try:
            mkdir(args.out_dir)
        except OSError:
            print("The output dir exists, overwriting it")
            rmtree(args.out_dir)
            mkdir(args.out_dir)

            with open('{0}/program.txt'.format(args.out_dir), 'w') as f:
                P.dump(f)

        if not args.no_tests:
            testgen = TestCaseGenerator(args.out_dir, args.all_tests)

    P.setEntry(entry)

    assert args.se, "We only support symbolic execution now"

    opts = SEOptions()
    opts.concretize_nondets = args.concretize_nondet
    opts.uninit_is_nondet = args.uninitialized_nondet
    if args.step == 'block':
        opts.setBlockStep()
    opts.interactive = args.interactive

    if args.kind:
        from slowbeast.kindse.kindse import KindSymbolicExecutor
        SE = KindSymbolicExecutor(P, testgen, opts)
    else:
        from slowbeast.symexe.symbolicexecution import SymbolicExecutor
        SE = SymbolicExecutor(P, testgen, opts)
    try:
        SE.run()
        print_stats(SE)
    except KeyboardInterrupt:
        print_stdout("Interrupted...")
        print_stats(SE)

    exit(0)

if __name__ == "__main__":
    main()
